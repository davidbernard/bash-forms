This file is commandforms.def, from which is created commandforms.c.
It implements the builtins "fieldspec","formspec" and "form" in Bash.

Copyright (C) 1999-2002 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

Bash is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with Bash; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.

$PRODUCES commandforms.c

$BUILTIN fieldspec
$DEPENDS_ON COMMAND_FORMS
$FUNCTION fieldspec_builtin
$SHORT_DOC field_spec [-pr] +label <label> +fieldtype flag|flagwithvalue|positional|uptolast|last|rest [+hinttext <hint text>] [+helptext <help text>]  [+displaylevel simple|general|advanced] [ +compspec <compspec name> ] <fieldspec name> ...
This command defines a type of field for display on a command form.
$END

#include <config.h>


#include "bashtypes.h"

#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#include "../bashansi.h"

#include "../shell.h"
#include "../builtins.h"
#include "../commandforms.h"
#include "../pcomplete.h"

#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#include "../bashline.h"
#include <readline/readline.h>
#include <readline/tcap.h>
#endif

#define STRDUP(x)       ((x) ? savestring (x) : (char *)NULL)



static int fieldspec_removeall __P((WORD_LIST *));
static int remove_formspecs __P((WORD_LIST *));
static void formspec_printall __P((void));
static int formspec_printlist __P((WORD_LIST *));
static void fieldspec_printall __P((void));
static int fieldspec_printlist __P((WORD_LIST *));
static SCREENFORM *(screenform_init(FORMSPEC *form, char *label));
static void screenform_layout(SCREENFORM *screenform);
static void screenform_displayhinttext(SCREENFORM *screenform);
static void screenform_draw(SCREENFORM *screenform);
static void screenform_gotofield(SCREENFORM *screenform, SCREENFIELD *screenfield);


/* Build the field specfication in LIST.
    Return value:
   	EX_USAGE = bad option
   	EXECUTION_SUCCESS = some options supplied
   	EXECUTION_FAILURE = no options supplied
*/

/* Add, remove, and display field specifiers. */
int
fieldspec_builtin ( WORD_LIST *list)
{
  FIELDSPEC *cs;
  WORD_LIST *l;
  WORD_LIST *ll;
  char *ip;
  char *op;
  int i;

		char *fieldtype;
        char *hinttext;
        char *helptext;
        char *label;
        char *displaylevel;
        char *compspec;
        char *flag;
        char **values;
		int valueslength;
		int valuescount;
		WORD_LIST *valueslist;
        char **displayvalues;
		int displayvalueslength;
 		int displayvaluescount;
		WORD_LIST *displayvalueslist;
	int pflag= 0;
	int rflag= 0;

  if (list == 0)
    {
      fieldspec_printall ();
      return (EXECUTION_SUCCESS);
    }



	fieldtype = NULL;
	hinttext = NULL;
	helptext = NULL;
	label = NULL;
	displaylevel = NULL;
	values = NULL;
	displayvalues = NULL;
	valueslist = NULL;
	displayvalueslist = NULL;
	valuescount = 0;
	displayvaluescount = 0;
	compspec = NULL;
	flag = NULL;
	valueslength = 0;
	displayvalueslength = 0;

  for (l = list; l; )
	{
		if ( strcmp("-p", l->word->word) == 0)
		{
			pflag = 1;
		}
		else if ( strcmp("-r", l->word->word) == 0)
		{
			rflag = 1;
		}
#define CHECKFORSTRINGARG(arg, variable)\
		else if ( strcmp(arg, l->word->word) == 0) \
		{ \
			if ( l->next) \
			{ \
				variable = savestring(l->next->word->word); \
				l = l->next; \
			} \
			else \
			{ \
				  builtin_error ("%s: invalid action name", list_optarg); \
				  goto usage_error; \
			} \
		}


		else if ( strcmp("+values", l->word->word) == 0)
		{
			valueslist= l->next;
			valueslength = 0;
			valuescount = 0;
			/* Determine the length the values string will need 
				Note: Last word is always command */
			for ( ll = l->next; ll->next; ll = ll->next)
			{
				if ( ll->word->word[0] == '+' )
				{
					l = ll;
					goto next;
				}
				else
					{
					valueslength += strlen(ll->word->word) + 1;
					valuescount++;
					}
				
			}
			l = ll;
			goto next;
		}
		else if ( strcmp("+displayvalues", l->word->word) == 0)
		{
			displayvalueslist= l->next;
			displayvalueslength = 0;
			displayvaluescount = 0;
			/* Determine the length the values string will need 
				Note: Last word is always command */
			for ( ll = l->next; ll->next; ll = ll->next)
			{
				if ( ll->word->word[0] == '+' )
				{
					l = ll;
					goto next;
				}
				else
					{
					displayvalueslength += strlen(ll->word->word) + 1;
					displayvaluescount++;
					}
				
			}
			l = ll;
			goto next;
		}
		CHECKFORSTRINGARG("+fieldtype", fieldtype)
		CHECKFORSTRINGARG("+hinttext", hinttext)
		CHECKFORSTRINGARG("+helptext", helptext)
		CHECKFORSTRINGARG("+label", label)
		CHECKFORSTRINGARG("+displaylevel", displaylevel)
		CHECKFORSTRINGARG("+compspec", compspec)
		CHECKFORSTRINGARG("+flag", flag)
		else
		{
		  break;
		}

	l = l->next;
next:
	/* l progressed */
  ;
	}



  /* -p overrides everything else */
  if (pflag || (list == 0 ))
    {
      if (l == 0)
	{
	  fieldspec_printall ();
	  return (EXECUTION_SUCCESS);
	}
	else
          return (fieldspec_printlist (list));
    }

  /* next, -r overrides everything else. */
  if (rflag)
    {
      if (l == 0)
	{
	  fieldspecs_flush ();
	  return (EXECUTION_SUCCESS);
	}
      else
          return (fieldspec_removeall (l));
    }

   list = l;
  if (list == 0 )
    {
      builtin_usage ();
      return (EX_USAGE);
    }

	if ( fieldspec_search(l->word->word) != 0)
	{
		builtin_error ("%s: fieldspec already exists", l->word->word);
		return (EX_USAGE);
	}
	/* Check for each display value there is a value */
	if ( displayvaluescount > 0 && valuescount != displayvaluescount )
	{
		builtin_error ("%s: 'values' and 'displayvalues' must have same number of values", l->word->word);
		return(EX_USAGE);
	}

  /* If we get here, we need to build a fieldspec and add it for each
     remaining argument. */
  cs = fieldspec_create ();
  cs->valuescount = valuescount;


	if ( fieldtype && *fieldtype )
	{
	  if ( strcmp(fieldtype, "positional") == 0)
		cs->fieldtype = FIELDTYPE_POSITIONAL;
	  else if ( strcmp(fieldtype, "flag") == 0)
		cs->fieldtype = FIELDTYPE_FLAG;
	  else if ( strcmp(fieldtype, "last") == 0)
		cs->fieldtype = FIELDTYPE_LAST;
	  else if ( strcmp(fieldtype, "rest") == 0)
		cs->fieldtype = FIELDTYPE_REST;
	  else if ( strcmp(fieldtype, "uptolast") == 0)
		cs->fieldtype = FIELDTYPE_UPTOLAST;
	  else if ( strcmp(fieldtype, "flagwithvalue") == 0)
		cs->fieldtype = FIELDTYPE_FLAGWITHVALUE;
	  else
		{
		free(cs);
		builtin_error ("%s: Invalid field type", fieldtype);
		return(EX_USAGE);
		}
	}
	else
		cs->fieldtype = FIELDTYPE_POSITIONAL;

	if ( displaylevel && *displaylevel )
	{
	  if ( strcmp(displaylevel, "simple") == 0)
		cs->displaylevel = CF_DISPLAYLEVEL_SIMPLE;
	  else if ( strcmp(displaylevel, "general") == 0)
		cs->displaylevel = CF_DISPLAYLEVEL_GENERAL;
	  else if ( strcmp(displaylevel, "advanced") == 0)
		cs->displaylevel = CF_DISPLAYLEVEL_ADVANCED;
	  else
		{
		free(cs);
		builtin_error ("%s: Invalid display level", displaylevel);
		return(EX_USAGE);
		}
	}
	else
		cs->displaylevel = CF_DISPLAYLEVEL_SIMPLE;

  cs->hinttext = STRDUP (hinttext);
  cs->helptext = STRDUP (helptext);
  if ( label )
	cs->label = STRDUP (label);
  else
	cs->label = STRDUP(list->word->word);

  
	if ( valuescount > 0)
	{
		cs->values = xmalloc((unsigned int)(valuescount * sizeof(char *)) );
		cs->values[0] = xmalloc((unsigned int)valueslength);

		op = cs->values[0];
		for(i=0, ll = valueslist; ll->next; i++, ll = ll->next)
		{
			if ( ll->word->word[0] == '+' )
				break;
			else
			if ( ll->word->word[0] == '\\')
				ip =  ll->word->word + 1;
			else
				ip =  ll->word->word;
			cs->values[i] = op;

			while( (*op++ = *ip++) ) ;
			
		}
		*op = '\0';
	}

	if ( displayvaluescount > 0)
	{
	  cs->displayvalues = xmalloc((unsigned int)(valuescount * sizeof(char *)) );
	  cs->displayvalues[0] = xmalloc((unsigned int)displayvalueslength);

	  op = cs->displayvalues[0];
	  for(i=0, ll = displayvalueslist; ll->next; i++, ll = ll->next)
		{
			if ( ll->word->word[0] == '+' )
				break;
			else
			{
				ip =  ll->word->word;
				cs->displayvalues[i] = op;
				while( (*op++ = *ip++) ) ;
			}
			
		}
		*op = '\0';
	}
	else
	{
		/* Have displayvalues point to same place 
		   Note: When freeing fieldspec must check before freeing displayvalues */
		cs->displayvalues = cs->values;
	}

  cs->compspec = STRDUP (compspec);
  cs->flag = STRDUP (flag);

  if (fieldspec_insert (list->word->word, cs) == 0)
		return(EXECUTION_FAILURE);
  else
	  return (EXECUTION_SUCCESS);

usage_error:
	/* XXXXXX */
	return EX_USAGE;
}

/*
 Remove all field specifiers
 */
static int
fieldspec_removeall (list)
     WORD_LIST *list;
{

  WORD_LIST *l;
  int ret;

  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (fieldspec_remove (l->word->word) == 0)
	  {
		  builtin_error ("%s: no fieldspec specification or fieldspec in use", l->word->word);
		  ret = EXECUTION_FAILURE;
	  }
    }
  return ret;
}

/*
	Print field specification
 */
#define CONDITIONALSQPRINTSTRING(a, f) \
    if (a && *a) \
      { \
      	x = sh_single_quote (a); \
	printf ("%s %s ", f, x); \
	free (x); \
      } 

#define CONDITIONALPRINTDOUBLE(a, f) \
    if (a != 0.0 ) \
      printf ("%s %g ", f, a); 

#define CONDITIONALPRINTINT(a, f) \
    if (a != 0 ) \
      printf ("%s %d ",  f, a); 

#define CONDITIONALPRINTSTRING(a, f) \
    if ( a && *(a) )  \
      printf ("%s %s", f, a); 

static int
fieldspec_print ( char *cmd, FIELDSPEC *cs)
{
  char *x;
	char *string;

  printf ("fieldspec ");

  string = NULL;
	if ( cs->fieldtype == FIELDTYPE_FLAG)
		string = "flag";
	else if ( cs->fieldtype == FIELDTYPE_FLAGWITHVALUE)
		string = "flagwithvalue";
	else if ( cs->fieldtype == FIELDTYPE_POSITIONAL)
		string = "positional";
	else if ( cs->fieldtype == FIELDTYPE_UPTOLAST)
		string = "uptolast";
	else if ( cs->fieldtype == FIELDTYPE_LAST)
		string = "last";
	else if ( cs->fieldtype == FIELDTYPE_REST)
		string = "rest";
  CONDITIONALSQPRINTSTRING(string, "+fieldtype");
  CONDITIONALSQPRINTSTRING(cs->hinttext, "+hinttext")
  CONDITIONALSQPRINTSTRING(cs->helptext, "+helptext")
  CONDITIONALSQPRINTSTRING(cs->label, "+label")
  CONDITIONALSQPRINTSTRING(cs->compspec, "+compspec")
  CONDITIONALSQPRINTSTRING(cs->flag, "+flag")

  printf ("%s\n", cmd);

  return (0);
}

/*
	Helper function called to print a field spec from a walk
	of field spec hash
 */
static int
fieldspec_printitem ( BUCKET_CONTENTS *item)
{
  FIELDSPEC *cs;
  char *cmd;

  cmd = item->key;
  cs = (FIELDSPEC *)item->data;

  return (fieldspec_print (cmd, cs));
}

/*
	Print all field specs by walking hash
 */
static void
fieldspec_printall ()
{
  fieldspecs_walk (fieldspec_printitem);
}

/*
 	Print all field spec in a list 
 */
static int
fieldspec_printlist (list)
     WORD_LIST *list;
{
  WORD_LIST *l;
  FIELDSPEC *cs;
  int ret;

  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      cs = fieldspec_search (l->word->word);
      if (cs)
	fieldspec_print (l->word->word, cs);
      else
	{
	  builtin_error ("%s: no fieldspec specification", l->word->word);
	  ret = EXECUTION_FAILURE;
	}
    }
  return (ret);
}

$BUILTIN formspec
$DEPENDS_ON COMMAND_FORMS
$FUNCTION formspec_builtin
$SHORT_DOC formspec [-pr] +screenfieldlist fieldname ... +generationfieldlist field name ... +commands cmd ...
This command defines a type of form for display of a command form.
$END



/* Build the form specfication in LIST.
   	EX_USAGE = bad option
   	EXECUTION_SUCCESS = some options supplied
   	EXECUTION_FAILURE = no options supplied
*/

/* Add, remove, and display form specifiers. */
int
formspec_builtin ( WORD_LIST *list)
{
  int rval;
  FORMSPEC *fs;
  WORD_LIST *l;
  WORD_LIST *ll;
  WORD_LIST *lll;
  WORD_LIST *screenfieldlist = (WORD_LIST *)0;
  WORD_LIST *generationfieldlist = (WORD_LIST *)0;
  WORD_LIST *commandlist = (WORD_LIST *)0;

  int pflag= 0;
  int rflag= 0;
  int screenfieldcount = 0;
  int generationfieldcount = 0;
  int i;
  int j;


  if (list == 0)
    {
      formspec_printall ();
      return (EXECUTION_SUCCESS);
    }

  for (l = list; l; l = l->next)
  {
  	if ( strcmp("-p", l->word->word) == 0)
	{
		pflag = 1;
	}
	else if ( strcmp("-r", l->word->word) == 0)
	{
		rflag = 1;
	}
	else if ( strcmp("+screenfieldlist", l->word->word) == 0)
	{
		/* Count screenfieldlist*/
		screenfieldlist= l->next;
		for(ll=l->next; ll; ll = ll->next)
		{
			if ( ll->word->word[0] == '+' )
				break;
			else
				screenfieldcount++;
			if ( (FIELDSPEC *)0 == fieldspec_search(ll->word->word) )
			{
		        	builtin_error ("%s: Invalid field name", ll->word->word); \
				goto usage_error;
				
			}
			l = ll;
		}
	}
	else if ( strcmp("+generationfieldlist", l->word->word) == 0)
	{
		/* Count generationfieldlist*/
		generationfieldlist= l->next;
		for(ll=l->next; ll; ll = ll->next)
		{
			if ( ll->word->word[0] == '+' )
				break;
			else
				generationfieldcount++;
			if ( (FIELDSPEC *)0 == fieldspec_search(ll->word->word) )
			{
		        	builtin_error ("%s: Invalid field name", ll->word->word); \
				goto usage_error;
				
			}
			l = ll;
		}
	}
	else if ( strcmp("+commands", l->word->word) == 0)
	{
		/* Check for consistancy */
		commandlist= l->next;
		break;
	}
	else
	{
	  break;
	}
 }



  /* -p overrides everything else */
  if (pflag || (list == 0 ))
    {
      if (l == 0)
	{
	  formspec_printall ();
	  return (EXECUTION_SUCCESS);
	}
	else
          return (formspec_printlist (list));
    }

  /* next, -r overrides everything else. */
  if (rflag)
    {
      if (l == 0)
	{
	  formspecs_flush ();
	  return (EXECUTION_SUCCESS);
	}
      else
          return (remove_formspecs (l));
    }

  if (commandlist == 0 )
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  /* Check that every screen list entry has a generation list entry */
  if ( generationfieldlist != (WORD_LIST *)0 )
  {
    if ( screenfieldcount != generationfieldcount)
    {
	builtin_error (": screen field count (%d) != generation field count (%d)", screenfieldcount, generationfieldcount);
	goto usage_error;
    }
  for (i=0, ll=screenfieldlist; i<screenfieldcount; i++, ll= ll->next)
	{
	  for (j=0, lll=generationfieldlist; j<generationfieldcount; j++, lll= lll->next)
	    {
	    if ( 0 ==  strcmp( ll->word->word, lll->word->word) )
		break;
	    }
	  if ( lll == (WORD_LIST *)0)
	  {
	  builtin_error ("%s: screen list item not in generation list ", ll->word->word);
		goto usage_error;
	  }
	}
  }
  /* If we get here, we need to build a formspec and add it for each
     remaining argument. */
  fs = formspec_create ();

 /* Allocate space for field lists */
  fs->screenfieldlist = (FORMFIELDSPEC **)xmalloc (sizeof(FORMFIELDSPEC *) * (screenfieldcount + 1 ));
  fs->generationfieldlist = (FORMFIELDSPEC **)xmalloc (sizeof(FORMFIELDSPEC *) * (generationfieldcount + 1 ));

  for (i=0, ll=screenfieldlist; i<screenfieldcount; i++, ll= ll->next)
  {
	fs->screenfieldlist[i]= (FORMFIELDSPEC *)xmalloc(sizeof(FORMFIELDSPEC));
	fs->screenfieldlist[i]->fieldspec= fieldspec_search(ll->word->word);
	fs->screenfieldlist[i]->fieldspecname= savestring(ll->word->word);
	fieldspec_retain(fs->screenfieldlist[i]->fieldspec);
	if ( generationfieldcount == 0)
	{
		fs->generationfieldlist[i]= (FORMFIELDSPEC *)xmalloc(sizeof(FORMFIELDSPEC));
		fs->generationfieldlist[i]->fieldspec= fieldspec_search(ll->word->word);
		fs->generationfieldlist[i]->fieldspecname= savestring(ll->word->word);
	}
  }
  fs->screenfieldlist[screenfieldcount] = (FORMFIELDSPEC *)0;

  if ( generationfieldcount != 0)
    for (i=0, ll=generationfieldlist; i<generationfieldcount; i++, ll= ll->next)
    {
	fs->generationfieldlist[i]= (FORMFIELDSPEC *)xmalloc(sizeof(FORMFIELDSPEC));
	fs->generationfieldlist[i]->fieldspec= fieldspec_search(ll->word->word);
	fs->generationfieldlist[i]->fieldspecname= savestring(ll->word->word);
    }
  fs->generationfieldlist[screenfieldcount] = (FORMFIELDSPEC *)0;
  fs->fieldcount = screenfieldcount;

  list = commandlist;
  for (rval = EXECUTION_SUCCESS ; list; list = list->next)
    {
      /* Add formspec  as the formspec for the specified forms. */
      if (formspec_insert (list->word->word, fs) == 0)
	rval = EXECUTION_FAILURE;
    }

  return (rval);

usage_error:
	builtin_usage();
	return EX_USAGE;
}

/*
	Remove all form specifiers 
 */
static int
remove_formspecs (list)
     WORD_LIST *list;
{

  WORD_LIST *l;
  int ret;

  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (formspec_remove (l->word->word) == 0)
	{
	  builtin_error ("%s: no formspec specification", l->word->word);
	  ret = EXECUTION_FAILURE;
	}
    }
  return ret;
}

/* 
	Print a form specifier
 */
static int
formspec_print ( char *cmd, FORMSPEC *form)
{
	
  FORMFIELDSPEC **l;

  printf ("formspec ");
  
  printf("+screenfieldlist ");
  for(l=form->screenfieldlist; *l; l++)
  {
      printf("%s ", (*l)->fieldspecname);
  }
  printf("+generationformlist ");
  for(l=form->generationfieldlist; *l; l++)
  {
      printf("%s ", (*l)->fieldspecname);
  }
  printf ("%s\n", cmd);

  return (0);
}

static int
formspec_printitem ( BUCKET_CONTENTS *item)
{
  FORMSPEC *cs;
  char *cmd;

  cmd = item->key;
  cs = (FORMSPEC *)item->data;

  return (formspec_print (cmd, cs));
}

/* 
	Print all form specifiers by walking hash
 */
static void
formspec_printall (void)
{
  formspecs_walk (formspec_printitem);
}

/* 
	Print a list of form specifiers
 */
static int
formspec_printlist ( WORD_LIST *list)
{
  WORD_LIST *l;
  FORMSPEC *cs;
  int ret;

  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      cs = formspec_search (l->word->word);
      if (cs)
	formspec_print (l->word->word, cs);
      else
	{
	  builtin_error ("%s: no formspec specification", l->word->word);
	  ret = EXECUTION_FAILURE;
	}
    }
  return (ret);
}

$BUILTIN form
$DEPENDS_ON COMMAND_FORMS
$FUNCTION form_builtin
$SHORT_DOC form [-x]  [-l] command arg1 arg2 ..
Display the form for the command.
$END

static rl_hook_func_t *old_rl_startup_hook = (rl_hook_func_t *)NULL;
static int screenform_displayvalue(void);
static void screenfield_setwithdisplayvalue(SCREENFIELD *screenfield, char *displayvalue, int partial);
static void screenfield_setwithindex(SCREENFIELD *screenfield, int valueindex);


static int cf_readline_initialized = 0;
static CF_EDIT_MODE cf_edit_mode = CF_MODE_FORM;
static CF_EXECUTION_MODE cf_execution_mode = CF_MODE_DISPLAY;
static Keymap cf_keymap;

static int fieldspec_displayvalueindex(FIELDSPEC *fieldspec, char *displayvalue,
		int partial);

/*
	Function to process a key key press. Called from the 
	keymap table during readline.
	The function either inserts the type character or if 
	the field has a display value list, it navigates between 
	displayvalue.
 */
static int cf_insert_or_cycle_screenfield ( int count, int c)
{
	SCREENFIELD *screenfield ;
	char buff[2];
	int valueindex;
	
	buff[0] = (char)c;
	buff[1] = '\0';


	if ( cf_screenform )
	{
		screenfield = cf_screenform->currentscreenfield;
		/* If value to display mapping */
		if ( screenfield->fieldspec->valuescount > 1)
		{
			if ( c == ' ')
			{
				if ( screenfield->currentvalueindex == -1)
				{
					screenfield_setwithindex(screenfield, 0);
				} 
				else if ( screenfield->currentvalueindex < 
						(screenfield->fieldspec->valuescount-1) )
				{
					screenfield_setwithindex(screenfield, 
						screenfield->currentvalueindex + 1);
				}
				else
				{
					screenfield_setwithindex(screenfield, 
						0);
				}
			}
			else
			{
				/* Set with partial match */
				valueindex = fieldspec_displayvalueindex(screenfield->fieldspec, 
						buff, 1);
				if ( valueindex != -1)
				{
					screenfield_setwithindex(screenfield, valueindex);
				}
				else
				{
					rl_ding();
				}
			}
			rl_replace_line(screenfield->displayvalue, 0);
			rl_point = rl_end;
			rl_mark = 0;
			return 0;
		}
	}

	/* Otherwise */
	return rl_insert(count, c);
} 
/*
 	Process Right arrow key
 */
static int cf_right_arrow_key(int count, int c)
{
	SCREENFIELD *screenfield ;

	if ( cf_screenform )
	{
		screenfield = cf_screenform->currentscreenfield;
		/* If value to display mapping */
		if ( screenfield->fieldspec->valuescount > 1)
		{
			if ( screenfield->currentvalueindex < 
					(screenfield->fieldspec->valuescount-1) )
			{
				screenfield_setwithindex(screenfield, 
					screenfield->currentvalueindex + 1);
			}
			else
			{
				screenfield_setwithindex(screenfield, 
					0);
			}
			rl_replace_line(screenfield->displayvalue, 0);
			rl_point = rl_end;
			rl_mark = 0;
			return 0;
		}
#if defined(SELECTFROMCOMPLETION)
		else if (screenfield->completionlist)
		{
			if ( screenfield->completioncurrentindex == -1 )
			{
				screenfield->completioncurrentindex = 
					screenfield->completionstartindex;
			}
			else if ( screenfield->completioncurrentindex < 
				(screenfield->completionlist->list_len - 1) )
			{
				screenfield->completioncurrentindex++;
			}
			screenfield_setwithdisplayvalue(screenfield,
				screenfield->completionlist
					->list[screenfield->completioncurrentindex]
					, 0);
			rl_replace_line(screenfield->displayvalue, 0);
			rl_point = rl_end;
			rl_mark = 0;
			return 0;
			
		}
#endif
	}
	/* Otherwise */
	return rl_forward_char (count, c);    
}
/*
 	Process left  arrow key
 */
static int cf_left_arrow_key(int count, int c)
{
	SCREENFIELD *screenfield;

	if ( cf_screenform )
	{
		screenfield = cf_screenform->currentscreenfield;
		/* If value to display mapping */
		if ( screenfield->fieldspec->valuescount > 1)
		{
			if ( screenfield->currentvalueindex > 0  
					)
			{
				screenfield_setwithindex(screenfield, 
					screenfield->currentvalueindex - 1);
			}
			else
			{
				screenfield_setwithindex(screenfield, 
					screenfield->fieldspec->valuescount - 1);
			}
			rl_replace_line(screenfield->displayvalue, 0);
			rl_point = rl_end;
			rl_mark = 0;
			return 0;
		}
#if defined(SELECTFROMCOMPLETION)
		else if (screenfield->completionlist)
		{
			if ( screenfield->completioncurrentindex == -1 )
			{
				screenfield->completioncurrentindex = 
					screenfield->completionnextindex-1;
			}
			if ( screenfield->completioncurrentindex > 0)
			{
				screenfield->completioncurrentindex--;
				screenfield_setwithdisplayvalue(screenfield,
					screenfield->completionlist
						->list[screenfield->completioncurrentindex]
						, 0);
				rl_replace_line(screenfield->displayvalue, 0);
				rl_point = rl_end;
				rl_mark = 0;
				return 0;
			}
			
		}
#endif
	}
    return rl_backward_char (count, c);
}

/*
	Process up arrow key
	Set navigation to previous field and complete entry of the field.
	
 */
static int cf_up_arrow_key(int count, int c)
{
	if ( cf_screenform )
	{
		cf_screenform->nextnavigation = CF_PREVIOUS_FIELD;
	}
    return rl_newline (count, c);
}
/*
	Process down arrow key
	Set navigation to next field and complete entry of the field.
	
 */
static int cf_down_arrow_key(int count, int c)
{
	if ( cf_screenform )
	{
		cf_screenform->nextnavigation = CF_NEXT_FIELD;
	}
    return rl_newline (count, c);
}
/*
 	Process redraw key sequence - Ctrl L
	Cycle display level and redraw the form
 */
static int cf_redraw(int count, int c)
{
	if ( cf_screenform )
	{
		cf_screenform->nextnavigation = CF_REDRAW;
	}
    return rl_newline (count, c);
}
static void screenform_hint(SCREENFORM *screenform, char *hint);

/*
	Callback function call by display_matches (readline library) to display the 
	possible matches on the hint line for automatic completion
 */
static void cf_display_matches(char **matches, int length, int max)
{

		
	STRINGLIST *sl;
	char *buff;
	SCREENFIELD *screenfield;
	SCREENFORM *screenform;
	FIELDSPEC *field;
	int i;
	int len;
	
	

	if ( ! cf_screenform )
		return;


	/* Context */
	screenform = cf_screenform;
	field = screenform->currentscreenfield->fieldspec;
	screenfield = screenform->currentscreenfield;

	/* Set up buffer */
	buff = xmalloc((unsigned int)(screenform->width+1));
	buff[0] = '\0';
	len = 0;

	/* First in list of displayed */
	if ( screenfield->completionlist )
	{
		if ( screenfield->completionnextindex >= 
					screenfield->completionlist->list_len )
			screenfield->completionstartindex = 0;
		else
			screenfield->completionstartindex = 
						screenfield->completionnextindex;
		for ( i = screenfield->completionstartindex,
				sl = screenfield->completionlist; i < sl->list_len; i++)
		{
			len += strlen(sl->list[i]) + 1;
			if ( len >=  screenform->width )
			{
				break;
			}
			else
			{
				strcat(buff, sl->list[i]);
				strcat(buff, " ");
			}
		}
		screenfield->completionnextindex = i;
	}
	/* exit displaying buffer */
	screenform_hint(screenform, buff);
	free(buff);

    rl_forced_update_display ();
	
}
/*
	Call by rl_completion_match (readline library) to pick up 
	all possible completions
 */
static char *cf_complete_return(const char *text, int state)
{
	static int valueindex = 0;
	char *string;

	if ( state == 0)
		valueindex = 0;
	
	if ( cf_screenform && cf_screenform->currentscreenfield &&
		cf_screenform->currentscreenfield->completionlist &&
		valueindex < (cf_screenform->currentscreenfield
				->completionlist->list_len - 1 ))
	{
		/* Not sure if we need to dupe here */
			string = 
				STRDUP(cf_screenform->currentscreenfield->completionlist->list[valueindex]);
			valueindex ++;
			return string;
	}
	else
		return NULL;
}
/* 
	Called via rl_attempted_completion global valiable
	Calculates a list of possible matches and the lowest common denominator
	and sets up if required the display of options on the hint line.
 */
static char **cf_completion( const char *text,int start, int end)
{

	SCREENFIELD *screenfield;	
	FIELDSPEC *field;
	int newlist;
	COMPSPEC *cs;
	STRINGLIST *sl = NULL;
	char **matches;
	static char *value = NULL;

	
	/* Sanity check */
	if ( ! cf_screenform )
		return NULL;

	/* Context */
	screenfield = cf_screenform->currentscreenfield;

	field = screenfield->fieldspec;

	newlist = 1;

	/* Locate */
	if ( value )
	{
		if ( strcmp(value, text) != 0 )
		{
			/* Value changed so save new value */
			free(value);
			value = STRDUP(text);
		}
		else 
		{
			/* Display next from completion list */
			newlist = 0;
		}
	}
	else
	{
		value = STRDUP(text);
	}

	/* If newlist required then dispose of old list */
	if ( newlist && screenfield->completionlist)
	{
		strlist_dispose(screenfield->completionlist);
		screenfield->completionlist = 0;
		screenfield->completioncurrentindex = -1;
	}

	if ( newlist || !screenfield->completionlist )
	{
		if ( field->compspec)
		{
			cs = progcomp_search(field->compspec);
			if ( cs )
				sl = gen_compspec_completions(cs, "compgen", 
						text, 0, 0);
			else
			{
				sl = NULL;
				fprintf(stderr, "Invalid completion spec for field %s\n",
					field->compspec);
			}

		}
		else
		{
			/* No completion spec so files and directories */
			cs = compspec_create();
			cs->actions = CA_FILE | CA_DIRECTORY;
			sl = gen_compspec_completions(cs, "compgen", 
					text, 0, 0);
			compspec_dispose(cs);
		}
		screenfield->completionlist = sl  ;
		screenfield->completionstartindex = 0  ;
		screenfield->completionnextindex = 0  ;
		screenfield->completioncurrentindex = -1  ;
	}
	else
	{
		screenfield->completionstartindex = screenfield->completionnextindex;
		if ( screenfield->completionstartindex >= 
				screenfield->completionlist->list_len )
		{
			screenfield->completionstartindex = 0;
		}
	}


	/* */
	matches = rl_completion_matches(text, cf_complete_return);
	return matches;
}


/*
	Initialise the keymap to be used for form input by cloning
	the current keymap
 */
static void cf_initialize_readline(void)
{
	static Keymap base_keymap = NULL;
	Keymap current_keymap;
	int i;


	current_keymap = rl_get_keymap();

	/* if base keymap still current - do nothing */
	if ( base_keymap != NULL
		&& base_keymap == current_keymap)
		return;

	/* if a different keymap is used free the command forms keymap */
	if ( base_keymap != NULL
		&& base_keymap != current_keymap 
		&& cf_keymap != NULL)
	{
		/* A different keymap is being used - recalculate keymap */
		rl_discard_keymap(cf_keymap);
		cf_keymap = NULL;
	}

	/* Record the keymap we based things on */
	base_keymap = current_keymap;

	/* Setup form keymaps by cloning other keymaps */
	cf_keymap = rl_copy_keymap(current_keymap);
	rl_set_keymap(cf_keymap);
	
	for (i = 0; i < KEYMAP_SIZE; i++)
	{
	    /* Replace rl_insert with cf_inser_or_navigate */
		if ( current_keymap[i].function ==
			rl_insert)
		{
			cf_keymap[i].function = cf_insert_or_cycle_screenfield;
		}
    }

	/* Disconnect from other sub keymaps */
	cf_keymap[ESC].function = (rl_command_func_t *)0x0;
	cf_keymap[ESC].type = ISFUNC;;
	
	/* Set arrow keys */
	rl_set_key( "\033[A", cf_up_arrow_key , cf_keymap);
	rl_set_key( "\033[B", cf_down_arrow_key , cf_keymap);
	rl_set_key( "\033[C", cf_right_arrow_key , cf_keymap);
	rl_set_key( "\033[D", cf_left_arrow_key , cf_keymap);


	/* Set arrow keys */
	rl_set_key( "\033[A", cf_up_arrow_key , cf_keymap);
	rl_set_key( "\033[B", cf_down_arrow_key , cf_keymap);
	rl_set_key( "\033[C", cf_right_arrow_key , cf_keymap);
	rl_set_key( "\033[D", cf_left_arrow_key , cf_keymap);

	/* Set redraw */
	cf_keymap[CTRL('l')].function = cf_redraw;
	cf_keymap[CTRL('l')].type = ISFUNC;;

	/* Set redraw */
	cf_keymap[CTRL('l')].function = cf_redraw;
	cf_keymap[CTRL('l')].type = ISFUNC;;

	
	rl_set_keymap(current_keymap);
	
	/* Mark as initialized */
	cf_readline_initialized = 1;
}

/*
	Set up the read line environmnent and call readline.
	Readline will redraw the label of the current screen field
	from the start of the line and will process input. 
	
	A call back function is used to populate the readline input
	with the display value of the field.
	
	Functions call from the "keymap" set the "next navigation" field
	of the global cf_screenform. This communicates the processing
	of up and down arrows to navigate between screen fields.

	The screen field value and display value are set from the 
	string returned by readline.
*/
extern int _rl_horizontal_scroll_mode;
static void
screenform_editscreenfield(SCREENFORM *screenform)
{
  char *ret;
  rl_completion_func_t *old_attempted_completion_function;
  rl_compdisp_func_t *old_completion_display_matches_hook;
  Keymap old_keymap;
  int old_rl_horizontal_scroll_mode;

	if (!bash_readline_initialized)
		initialize_readline ();

	if ( !cf_readline_initialized )
		cf_initialize_readline();

	/* Save readline state */
	old_keymap = rl_get_keymap();
	old_attempted_completion_function = rl_attempted_completion_function;
	old_completion_display_matches_hook = rl_completion_display_matches_hook;
	old_rl_horizontal_scroll_mode = _rl_horizontal_scroll_mode;


	/* Save the startup hook - restored in call back */
	old_rl_startup_hook = rl_startup_hook;

	/* Set call back to display contents of field */
	rl_startup_hook = screenform_displayvalue;

	/* Set custom completion functions */
	rl_attempted_completion_function = cf_completion;
	rl_completion_display_matches_hook = cf_display_matches;

	/* XXXXXX Set required key map */
	rl_set_keymap(cf_keymap);

	/* Set horizontal scroll mode */
	_rl_horizontal_scroll_mode = 1;

	/* Read line of input redisplaying field label */
	ret = readline(screenform->currentscreenfield->label);

	/* Restore readline state */
	rl_attempted_completion_function = old_attempted_completion_function;
	rl_set_keymap(old_keymap);
	_rl_horizontal_scroll_mode = old_rl_horizontal_scroll_mode;
	rl_completion_display_matches_hook = old_completion_display_matches_hook;
	
	/* Set the value using the displayed data */
	screenfield_setwithdisplayvalue(screenform->currentscreenfield, ret, 0);
}

/*
	This function is called from within readline and "pretends" to have 
	"inserted" the value of the current screen form field.
	The effect is to display the value of the field and position the 
	cursor at the start of the field. The use can then use the readline edit
	commands to edit the value.
 */
static int
screenform_displayvalue (void)
{
  if (cf_screenform->currentscreenfield->value)
    {
      rl_insert_text (cf_screenform->currentscreenfield->displayvalue);
		/* If field wider than display width set edit point at start of field */
	  if ( (strlen(cf_screenform->currentscreenfield->displayvalue)
			+  cf_screenform->maxlabelwidth + 3)
			> cf_screenform->width )
		  rl_point = 0;
    }
  rl_startup_hook = old_rl_startup_hook;
  return 0;
}

/*
	Determine the index into the translation table for a value.
 */
static int fieldspec_valueindex(FIELDSPEC *fieldspec, char *value)
{
	int i;
	for (i=0; i<fieldspec->valuescount; i++)
	{
		if (strcmp(fieldspec->values[i], value) == 0 )
			return i;
	}
	return -1;
}
/*
	Determine the index into the translation table for a display value.
 */
static int fieldspec_displayvalueindex(FIELDSPEC *fieldspec, char *displayvalue,
		int partial)
{
	int i;
	int len = strlen(displayvalue);

	for (i=0; i<fieldspec->valuescount; i++)
	{
		if ( partial )
		{
			if (strncasecmp(fieldspec->displayvalues[i], displayvalue, (unsigned int)len) == 0 )
				return i;
		}
		else
		{
			if (strcmp(fieldspec->displayvalues[i], displayvalue) == 0 )
				return i;
		}
	}
	return -1;
}
/*
	Set the value of a screen field according to the index into the 
	table of allowable values for the field. The display value is set
	and the value for generation of the command.
 */
static void screenfield_setwithindex(SCREENFIELD *screenfield, int valueindex)
{
  FIELDSPEC *fieldspec;

	fieldspec = screenfield->fieldspec;

	/* Free existing values */
	if ( screenfield->value )
	{
		free(screenfield->value);
		screenfield->value = NULL;
	}
	if ( screenfield->displayvalue )
	{
		free(screenfield->displayvalue);
		screenfield->displayvalue = NULL;
	}

	if ( valueindex < fieldspec->valuescount &&
		valueindex > -1 )
	{
		screenfield->currentvalueindex = valueindex;
		screenfield->value = STRDUP(fieldspec->values[valueindex]);
		screenfield->displayvalue = STRDUP(fieldspec->displayvalues[valueindex]);
	}
	else
	{
	fprintf(stderr, "\n\n\n\n screenfield_setwithindex - invalid index %d where  valuescount is %d\n", valueindex, fieldspec->valuescount);	
	}

}
/*
	Set the value of a screen field from the value to be place in the generated
	command. If there is a translation between "value" and "display value" apply
 	the translation to populate the display value of the field.
 */
static void screenfield_setwithvalue(SCREENFIELD *screenfield, char *value)
{
  FIELDSPEC *fieldspec;
  int valueindex;

	fieldspec = screenfield->fieldspec;

	/* Free existing values */
	if ( screenfield->value )
	{
		free(screenfield->value);
		screenfield->value = NULL;
	}
	if ( screenfield->displayvalue )
	{
		free(screenfield->displayvalue);
		screenfield->displayvalue = NULL;
	}

	/* Set value and default index */
	screenfield->value = STRDUP(value);

	screenfield->currentvalueindex = -1;

	/* If there is a display translation check if value matches */
	if ( fieldspec->valuescount > 1 )
	{
		valueindex = fieldspec_valueindex(fieldspec, value);
		if ( valueindex != -1 )
		{
			screenfield->displayvalue = 
				STRDUP(fieldspec->displayvalues[valueindex]);
			screenfield->currentvalueindex = valueindex;
		}
		else
		{
			screenfield->displayvalue = STRDUP(value);
		}
	}
	else
	{
		screenfield->displayvalue = STRDUP(value);
	}
}
/*
	Set the value of a screen field from the value to be displayed. If there 
	is a translation between "value" and "display value" apply the reverse to
	populate the value of the field.
 */
static void screenfield_setwithdisplayvalue(SCREENFIELD *screenfield, char *displayvalue, int partial)
{
  FIELDSPEC *fieldspec;
  int valueindex;

	fieldspec = screenfield->fieldspec;

	/* Free existing values */
	if ( screenfield->value )
	{
		free(screenfield->value);
		screenfield->value = NULL;
	}
	if ( screenfield->displayvalue )
	{
		free(screenfield->displayvalue);
		screenfield->displayvalue = NULL;
	}

	/* Set value and default index */

	/* If there is a display translation check if value matches */
	if ( fieldspec->valuescount > 1 )
	{
		valueindex = fieldspec_displayvalueindex(fieldspec, displayvalue, partial);
		if ( valueindex != -1 )
		{
			screenfield_setwithindex(screenfield, valueindex);
			return;
		}
	}

	/* Otherwise  set everything as entered */
	screenfield->currentvalueindex = -1;
	screenfield->displayvalue = STRDUP(displayvalue);
	screenfield->value = STRDUP(displayvalue);
}
/*
	Append a string to a screen field
 */
static void screenfield_appendtovalue(SCREENFIELD *screenfield, char *value)
{
	int length;
	char *oldvalue;
	char *newvalue;

	if ( screenfield->value)
	{
		length = strlen(screenfield->value) + strlen(value) + 2;
		oldvalue = screenfield->value;
		newvalue = xmalloc((unsigned int)length);
		strcpy(newvalue, oldvalue);
		strcat(newvalue, " ");
		strcat(newvalue, value);
		screenfield_setwithvalue(screenfield, newvalue);
		free(newvalue);
	}
	else
	{
		screenfield_setwithvalue(screenfield, value);
	}
}
/* 
	Populate the screen field values from the passed in arguments and 
	set unspecificed arguments to their defaults.	
*/
static void screenform_populatefieldsfrompartialcommand(SCREENFORM *screenform, WORD_LIST *list)
{
	
WORD_LIST *l;
  FORMFIELDSPEC **fieldlist;
  FORMFIELDSPEC **fl;
  FIELDSPEC *fieldspec;
  SCREENFIELD *screenfield;
  int valueindex;
  int found;


	fieldlist = screenform->formspec->generationfieldlist;
	for (l = list->next; l && *fieldlist; l = l->next)
	{
		fieldspec = (*fieldlist)->fieldspec;
		screenfield = fieldspec->screenfield;

		/* If next fieldspec is a flag then try to match
		   the argument to any flags before the next positional argument */

		if ( fieldspec->fieldtype == FIELDTYPE_FLAG
			|| FIELDTYPE_FLAGWITHVALUE)
		{
			/* Check for matching flag arguments prior to next positional */
			found = 0;

			for (fl = fieldlist; *fl && 
				( (*fl)->fieldspec->fieldtype == FIELDTYPE_FLAG ||
				 (*fl)->fieldspec->fieldtype == FIELDTYPE_FLAGWITHVALUE); fl++)
			{
				fieldspec = (*fl)->fieldspec;
				screenfield = fieldspec->screenfield;

				/* Test for matching flag value */
				if ( fieldspec->fieldtype == FIELDTYPE_FLAGWITHVALUE
						&&  fieldspec->flag)
				{
					int flaglen = strlen(fieldspec->flag);

					if ( strcmp(fieldspec->flag, l->word->word) == 0 ||
							 (fieldspec->flag[flaglen-1] == ' ' &&
							strncmp(fieldspec->flag, l->word->word,
								flaglen-1) == 0) )
					{
						/* Should be another value */
						if ( l->next )
						{
							/* Consume value */
							screenfield_setwithvalue(screenfield, 
								l->next->word->word);
							l = l->next;
						}
						/* Consume argument 
							but don't progress field list pointer  
							as there may be other flags */
						found = 1;
						break;
					}
					else if ( strncmp(fieldspec->flag, l->word->word, 
								flaglen) == 0)
					{
						/* split flag from word and set vallue */
						screenfield_setwithvalue(screenfield,
							l->word->word + flaglen);
						found = 1;
						break;
					}

				}
				else
				{
					/* Check whether it matches the on or off values */
					valueindex = fieldspec_valueindex(fieldspec, l->word->word) ;
					if ( valueindex != -1 )
					{
						/* Set the value of the field */
						screenfield_setwithindex(screenfield, valueindex);
					
						/* Consume argument 
							but don't progress field list pointer  
							as there may be other flags */
						found = 1;
						break;
					}
				}
			}
			/* If found then check next argument against flags */
			if ( found )
				continue;

			if ( !*fl)
			{
				/* No more positional arguments -
					all trailing */
				fieldlist = fl;
				break;
			}
			else
			{
				/* No matching flags so position to fieldspec  */
				fieldlist = fl;
				fieldspec = (*fieldlist)->fieldspec;
				screenfield = fieldspec->screenfield;
				/* Drop through */
			}
		}

		/* If a position argument is next then use the value */
		if ( fieldspec->fieldtype == FIELDTYPE_UPTOLAST)
		{
			/* If not last argument append to "UPTOLAST" field */
			if ( l->next != NULL )
			{
				screenfield_appendtovalue(screenfield, l->word->word);
				/* Note: Don't progress fieldlist */
			}
			else
			{
			/* Last argument so If next field is last field apply to that field */
				if ( *(fieldlist+1) &&
					(*(fieldlist+1))->fieldspec->fieldtype == FIELDTYPE_LAST)
				{
					screenfield_setwithvalue(
						(*(fieldlist+1))->fieldspec->screenfield,l->word->word);
				}
				else
				{
			/* Note: if no  LAST field after UPTOLAST then add to UPTOLAST */
					screenfield_appendtovalue(screenfield, l->word->word);
				}
			fieldlist++;
			}
		}
		else if ( fieldspec->fieldtype == FIELDTYPE_POSITIONAL
			|| fieldspec->fieldtype == FIELDTYPE_LAST)
		{
			/* Set value */
			screenfield_setwithvalue(screenfield, l->word->word);
			fieldlist++;
		}

		else if ( fieldspec->fieldtype == FIELDTYPE_REST)
		{
			/* Append all the rest to the field */
			screenfield_appendtovalue(screenfield, l->word->word);
			/* Note: Don't progress fieldlist */
		}
		else
			fprintf(stderr, "\n\n\n\nInvalid field type %d\n\n\n\n",
				fieldspec->fieldtype);
	}

	/* Set default values for unspecified fields */
	for ( fieldlist = screenform->formspec->generationfieldlist ; *fieldlist; fieldlist++)
	{
		fieldspec = (*fieldlist)->fieldspec;
		screenfield = fieldspec->screenfield;
	
		/* In value not populated then set default value */
		if ( screenfield->value == NULL )
			{
			if ( fieldspec->values )
				screenfield_setwithvalue(screenfield, fieldspec->values[0]);
			}
		
			
	}
}

/*
	Determine the length of the generated argument
 */
static int screenfield_generatedargumentlength(SCREENFIELD *screenfield)
{
	int len;

		len = 0;

		/* Length of flag */
		if ( screenfield->fieldspec->flag)
			len = strlen(screenfield->fieldspec->flag);

		/* Length of value - if value then flag otherwise nothing */
		if ( screenfield->value && strlen(screenfield->value) > 0)
			return len + strlen(screenfield->value);
		else
			/* If not value do not include length of flag */
			return 0;
}

/*
	Navigate to the next displayable screen field and make that field current
	Reports if there are no subsequent displayable fields.
 */
static int screenform_gotonextfield(SCREENFORM *screenform)
{
SCREENFIELD *screenfield;
SCREENFIELD *endofscreenfields;

	screenfield = screenform->currentscreenfield;
	endofscreenfields = (screenform->fieldcount-1) + screenform->screenfields;

	/* Find next displayable field */
	++screenfield;
	while ( screenfield <= endofscreenfields )
	{
		if( screenfield->fieldspec->displaylevel <= screenform->displaylevel)
		{
			screenform_gotofield(screenform, screenfield);
			return 1;
		}
		screenfield++;
	}
	/* No displayable fields found */
	screenform_gotofield(screenform, screenform->currentscreenfield);
	return 0;
}
/*
	Navigate to the previous displayable screen field and make that field current
 */
static void screenform_gotopreviousfield(SCREENFORM *screenform)
{
SCREENFIELD *screenfield;
SCREENFIELD *endofscreenfields;

	screenfield = screenform->currentscreenfield;
	endofscreenfields = (screenform->fieldcount-1) + screenform->screenfields;

	if ( screenfield == screenform->screenfields )
	{
		screenform_gotofield(screenform, screenfield);
		rl_ding();
		return;
	}

	screenfield--;
	/* Look for next displayable field */
	while ( screenfield >=  screenform->screenfields )
	{
		if( screenfield->fieldspec->displaylevel <= screenform->displaylevel)
		{
			screenform_gotofield(screenform, screenfield);
			return;
		}
		/* Otherwise */
		screenfield--;
	}
	/* No displayable fields found */
	rl_ding();
}
/*
	Generate the text to be put into the generated command for the screenfield
 */
static char * screenfield_generateargument(SCREENFIELD *screenfield)
{
	char *argument;
	int len;

		if ( screenfield->value )
		{
			len = strlen(screenfield->value);
			if ( screenfield->fieldspec->flag &&	
					len > 0)
			{
				len += strlen(screenfield->fieldspec->flag);
				argument = xmalloc((unsigned int)len+1);
				strcpy(argument, screenfield->fieldspec->flag);
				strcat(argument, screenfield->value);
			}
			else
			{
				argument = xmalloc((unsigned int)len+1);
				strcpy(argument, screenfield->value);
			}
			return argument;
		}
		else
			return NULL;
}

/* 
	Create a form specifier
 */


int
form_builtin (WORD_LIST *list)
{
  int rval;
  FORMSPEC *form;
  FORMFIELDSPEC **fieldlist;
  FIELDSPEC *field;
  SCREENFIELD *screenfield;
  SCREENFORM *screenform;
  WORD_LIST *l;
  int commandlength;
  char *command;
  char *command_name;
  char *cp;
  char *ip;
  int suppress_hint;
  char *argument;

	l = list;

	if (list == 0)
		return (EXECUTION_SUCCESS);

	if ( ! interactive )
	{
		builtin_error ("%s: Can only be run interactive", l->word->word);
		return(EXECUTION_FAILURE);
	}

	cf_edit_mode = CF_MODE_FORM;
	cf_execution_mode = CF_MODE_DISPLAY;

	for (l = list; l; )
	{
		if ( strcmp(l->word->word, "-l") == 0)
			cf_edit_mode = CF_MODE_LINE;
		else if ( strcmp(l->word->word, "-x") == 0)
			cf_execution_mode = CF_MODE_EXECUTE;
		else if ( l->word->word[0] != '-' )
			break;
		l = l->next;
	}
	
	command_name = l->word->word;
	form= formspec_search (command_name);
	
	/* XXX If form not loaded then seach form path and load form */

	/* Use form specification */
	if ( form)
	{

		/* Instansiate screenform */
		screenform = screenform_init(form, command_name);

		/* Layout form */
		screenform_layout(screenform);

		/* Parse the remaining arguments to populate field values */
		screenform_populatefieldsfrompartialcommand(screenform, l);
	
		/* Draw the form and position to first field */
		screenform_draw(screenform);

		/* Go to first field */
		screenform_gotofield(screenform, screenform->screenfields);

		/* Length of command plus space plus null */
		commandlength = strlen(command_name) + 2;

		
		/* Set global variable that will allow the 
			form navigation to be captured in the form edit code in readline */

		cf_screenform = screenform;
		/* Loop through fields */

			suppress_hint = 0;

			while ( 1 )
			{
				field = screenform->currentscreenfield->fieldspec;
				

				/* Default next navigation to next field */
				screenform->nextnavigation = CF_RETURN;
				
				/* Display hint text */
				if ( ! suppress_hint)
					screenform_displayhinttext(screenform);

				/* Edit the field */
				screenform_editscreenfield(screenform);
				screenform->currenty++;

				/* Note:
					Keystroke functions in readline/form_mode.c us the gobal
					cf_screenform to set "nextnavigation".
					This use of side effects is to avoid changing the main
					call of "readline". */

				switch (screenform->nextnavigation)
				{
				case CF_NO_NAVIGATION:
					screenform_gotofield(screenform, screenform->currentscreenfield);
					break;

				case CF_REDRAW:
					/* Redraw form */
					/* Go past end of current form */
					while( (screenform->currenty)++ < screenform->height )
						rl_crlf();

					rl_crlf();
					/* Cycle display level */
					if ( screenform->displaylevel == CF_DISPLAYLEVEL_ADVANCED)
						screenform->displaylevel = CF_DISPLAYLEVEL_SIMPLE;
					else
						screenform->displaylevel++;

					/* Re-layout and draw form */
					screenform_layout(screenform);
					screenform_draw(screenform);
					/* Go to first field */
					screenform_gotofield(screenform, screenform->screenfields);
					break;

				case CF_RETURN:
					/* Move to next field or 
						if last field or 
						last positional field complete form */
					if ( screenform->currentscreenfield <
						((screenform->fieldcount-1) + screenform->screenfields)
						&& (screenform->currentscreenfield
								->fieldspec->fieldtype != FIELDTYPE_LAST &&
							screenform->currentscreenfield
								->fieldspec->fieldtype != FIELDTYPE_REST ) )
						{
							if ( 0 == screenform_gotonextfield(screenform) )
								goto complete;
						}
					else
						/* Last field */
						goto complete;
					break;

				case CF_NEXT_FIELD:
					/* Navigate to next field */
					screenform_gotonextfield(screenform);
					break;
				case CF_PREVIOUS_FIELD:
					/* If not on field field move to previous field */
					screenform_gotopreviousfield(screenform);
					break;

				case CF_ENTER:
				case CF_ESCAPE:
					goto complete;
					break;
				
				}
				suppress_hint = 0;
			}

	complete: 

			/* Go to last line */
			if ( cf_edit_mode != CF_MODE_LINE )
				{
				while( (screenform->currenty)++ < screenform->height )
					rl_crlf();
				}

			/* Construct command string */

			/* 1. Determine command length */
			for(fieldlist=form->generationfieldlist; *fieldlist; fieldlist++)
			{
				field = (*fieldlist)->fieldspec;
				screenfield = field->screenfield;
				commandlength += screenfield_generatedargumentlength(screenfield) + 1;
			}

			/* 2. Start with command name */

			command = xmalloc((unsigned int)commandlength);
			cp = command;
			ip =  command_name;
			while ( (*cp++ = *ip++) ) ;
			cp--;
			
			/* 3. loop through the generate field list to construct command arguments */
			for(fieldlist=form->generationfieldlist; *fieldlist; fieldlist++)
			{
				field = (*fieldlist)->fieldspec;
				screenfield = field->screenfield;
				argument =  screenfield_generateargument(screenfield);
				
				if ( argument )
				{
					ip = argument;
					*cp++ = ' ';
					while ( (*cp++ = *ip++) ) ;
					cp--;
					free(argument);
				}
				/* 3. Release the value - not now needed */
				free(screenfield->value);
				free(screenfield->displayvalue);
				free(screenfield->label);
			}
			/* Note that command already null terminated */

			/* Free up screen fields */
			free(screenform->label);
			free(screenform->screenfields);
			cf_screenform = NULL;
			free(screenform);

			rl_crlf();
			if ( cf_execution_mode == CF_MODE_DISPLAY)
			{
				bash_re_edit(command);
				free(command);
			}
			else if ( cf_execution_mode == CF_MODE_EXECUTE)
			{
				/* Execute the command */
				fprintf(stderr, "%s\n", command);
				return parse_and_execute(command, "form", 0 );
			}
				
	}
	else
	{
		printf("Cannot find form '%s'\n", l->word->word);
	}
	rval = EXECUTION_SUCCESS;
	return (rval);
}


/* Helper  function to pass to tputs */
static int local_output_char(int c)
{
	return putc(c, stderr);
}

/*
	Change the current field and position the cursor to that the line of that
	field either using <CR> or UP character sequences.
 */
static void screenform_gotofield(SCREENFORM *screenform, SCREENFIELD *screenfield)
{
int i;
int delta;

	delta = screenform->currenty - screenfield->y;
	if ( delta > 0 )
	{
		if (cf_edit_mode == CF_MODE_FORM &&   UP && *UP)
			{
				for( i=0; i < delta; i++)
					tputs(UP, 1, local_output_char);
			}
	}
	else
	{
		for( i=0; i < -delta; i++)
		{
			putc('\n', stderr);
		}
	}
	screenform->currentscreenfield = screenfield;
	screenform->currenty = screenfield->y;
}

/*
	Draw text on the hint line of the screen by <CR> to
	go to the hint line, drawing the text up to the screen width
	and using the UP character sequence to go back to the line 
	you first started on.
	
 */
static void screenform_hint(SCREENFORM *screenform, char *hint)
{
int i;
int delta;

		if ( cf_edit_mode == CF_MODE_FORM &&
			 UP && *UP)
		{
			delta = (screenform->height - screenform->currenty) - 1;
		/* Go to hint line */
			for( i=0; i < delta; i++)
			{
				putc('\n', stderr);
			}

		/* Output hint on bottom line  - limit to screen width */
			i = strlen(hint) >
					screenform->width ?
				screenform->width :
				strlen(hint);
			fwrite(hint, 
				1, (unsigned int)i, stderr);
		/* Clear to end of line */
			for ( i = 
				strlen(hint); 
				i <screenform->width; i++)
				putc(' ', stderr);

		/* Go back to field */
			for( i=0; i < delta; i++)
				tputs(UP, 1, local_output_char);
		}
		else
		{
		/* If not UP suppported then just print the help text  
				- do not care if it goes over width of screen */
			fputs(hint, stderr);
			putc('\n', stderr);
		}
	/* Return to first column */
	/* Note that editscreenfield will redraw label */
		putc('\r', stderr);
}

/*
	Draw the hint text for currently displayed screen field
 */
static void screenform_displayhinttext(SCREENFORM *screenform)
{

	if ( screenform->currentscreenfield->fieldspec->hinttext)
	{
		screenform_hint(screenform, 
			screenform->currentscreenfield->fieldspec->hinttext);
	}

}
/*
	Initial drawing of complete screen form. Cursor is moved to first field. 
 */
static void screenform_draw(SCREENFORM *screenform)
{
SCREENFIELD *screenfield;

char *buff;
char *string;
int len;
char *cp;
int i;
int y;
char *displaylevel;



/* Display top line */
	buff = xmalloc((unsigned int)(screenform->width + 1));
	memset(buff, '-', (unsigned int)(screenform->width));
	buff[screenform->width] = '\0';
	len = strlen(screenform->label);
	cp = buff + ( (screenform->width/2) - (len/2) );
	if ( cp < buff)
	{
		cp = buff;
		len = screenform->width;
	}
	memcpy(cp, screenform->label, (unsigned int)len);

	/* Output string */
	fputs(buff, stderr);
	rl_crlf();

	
/* Display each field */

	y= 0;
	for(screenfield= screenform->screenfields, i=0; i<screenform->fieldcount ; screenfield++, i++)
	{
		if ( screenfield->fieldspec->displaylevel
					<= screenform->displaylevel)
		{
			/* Go to correct line */
			while(y < screenfield->y)
			{
				rl_crlf();
				y++;
			}
			/* Display label */
			fputs(screenfield->label, stderr);

			/* Display value */
			if ( screenfield->displayvalue)
			{
				len = strlen(screenfield->displayvalue) ;
				if ( (len + screenform->maxlabelwidth + 4) >
					screenform->width)
				{
					len = screenform->width - 
						screenform->maxlabelwidth - 5;
					fwrite(screenfield->displayvalue, 
						1, (unsigned int)len, stderr);
					putc('>', stderr);
				}
				else
				{
					fwrite(screenfield->displayvalue, 
						1, (unsigned int)len, stderr);
				}
			}

			/* Go to next line */
			rl_crlf();
			y++;

			/* If field is a LAST and not last field */
			if ( (screenfield->fieldspec->fieldtype == FIELDTYPE_LAST
					|| screenfield->fieldspec->fieldtype == FIELDTYPE_REST)
				&& i < (screenform->fieldcount-1) )
			{
				memset(buff, ' ', (unsigned int)(screenform->width));
				memset(buff, '+', (unsigned int)(screenform->maxlabelwidth));
				buff[screenform->width] = '\0';
				string = "flags";
				len = strlen(string);
				cp = buff + ( (screenform->maxlabelwidth/2) - (len/2) );
				if ( cp < buff)
				{
					cp = buff;
				}
				memcpy(cp, string, (unsigned int)len);

				/* Output string */
				fputs(buff, stderr);
				rl_crlf();
				y++;
			}
		}
	}

/* add a line for the hint text */
	memset(buff, '-', (unsigned int)(screenform->width));
	if ( screenform->displaylevel == CF_DISPLAYLEVEL_SIMPLE)
	{
		displaylevel = "simple";
	}
	else if ( screenform->displaylevel == CF_DISPLAYLEVEL_GENERAL)
	{
		displaylevel = "general";
	}
	else if ( screenform->displaylevel == CF_DISPLAYLEVEL_ADVANCED)
	{
		displaylevel = "advanced";
	}
	else
	{
		displaylevel = "undefined";
	}
	len = strlen(displaylevel);
	if (len > screenform->width)
		len = screenform->width/2;

	memcpy(buff + (screenform->width - len), displaylevel, (unsigned int)len);
	fputs(buff, stderr);
	rl_crlf();
	y++;
	rl_crlf();
	y++;

	/* Position to first field */
	screenform->currentx = 0;
	screenform->currenty = screenform->height;

	free(buff);
}

/*
	Layout the fields of the form for the current screen width
 */
static void screenform_layout(SCREENFORM *screenform)
{
FORMFIELDSPEC **fieldlist;
SCREENFIELD *screenfield;
FIELDSPEC *field;
int labelwidth;
int maxlabelwidth;
int y;
char *ap;
char *bp;

int rows;
int cols;



/* Get size of screen */

rl_get_screen_size(&rows, &cols);

/* Layout form */

/* 1. Determine label width */
	maxlabelwidth = 0;
	for(fieldlist=screenform->formspec->screenfieldlist, screenfield= screenform->screenfields; *fieldlist; fieldlist++, screenfield++)
	{
		field = (*fieldlist)->fieldspec;
		/* Cross link screenfield and fieldspec */
		field->screenfield = screenfield;
		screenfield->fieldspec = field;
		/* Check display level */
		if ( field->displaylevel <= screenform->displaylevel)
		{
			labelwidth = strlen(field->label);
			if ( labelwidth > maxlabelwidth)
				maxlabelwidth = labelwidth;
		}
	}
	/* hardcoded esthetic  
		IF label width greater than a third of screen width 	
				set label width to 20 */
	if ( maxlabelwidth > (cols / 3) )
		if ( maxlabelwidth > 20)
			maxlabelwidth = 20;

	screenform->maxlabelwidth = maxlabelwidth;
/* 2. Layout each field  - right align field labels */

	y= 0;
	for(fieldlist=screenform->formspec->screenfieldlist, screenfield= screenform->screenfields; *fieldlist; fieldlist++, screenfield++)
	{
		field = (*fieldlist)->fieldspec;
		if ( field->displaylevel <= screenform->displaylevel)
		{
			if ( field->displaylevel <= screenform->displaylevel)
				{
				if ( screenfield->label )
					free(screenfield->label);
				screenfield->label= xmalloc((unsigned int)(maxlabelwidth+2));
				memset(screenfield->label, ' ', (unsigned int)maxlabelwidth);
				labelwidth= strlen(field->label);
				for( ap= field->label, 
					bp= screenfield->label+(maxlabelwidth-labelwidth);
					*ap;
					bp++, ap++
					)
					*bp = *ap;
				
				/* Add delimiter */
				*bp++ = ':';
				*bp++ = ' ';
				*bp++ = '\0';
				screenfield->x = 0;
				screenfield->y = y;
				screenfield->inputy = y++;

				/* last field level space for separator */
				if ( field->fieldtype == FIELDTYPE_LAST ||
						field->fieldtype == FIELDTYPE_REST )
					y++;
	
				screenfield->inputx = maxlabelwidth + 1;
				screenfield->height = 1;
				/* XXXX defaulting to screen width */
				screenfield->width  = cols - maxlabelwidth - 1;
				/* Note: defaults set by screenform_polutatefrompartialcommand */
			}
		}
	}
	/*  Add line for hints */
	screenform->height = y+2;
	screenform->width = cols;
}
/*
   Instansiate a screen form, laying out the fields
 */
static SCREENFORM * screenform_init(FORMSPEC *formspec, char *label)
{
	SCREENFORM *screenform;


	/* Create SCREENFORM and SCREENFIELDs */
	screenform =  xmalloc(sizeof *screenform);
	memset(screenform, 0, sizeof(SCREENFORM) );


	/* Allocate screen fields */
	screenform->screenfields = (SCREENFIELD *)xmalloc( (unsigned int)(formspec->fieldcount * sizeof(SCREENFIELD) ) );
	memset(screenform->screenfields, 0, (unsigned int)(formspec->fieldcount * sizeof(SCREENFIELD) ));

	/* Initialising housekeeping */
	screenform->label = savestring(label);
	screenform->fieldcount = formspec->fieldcount;
	screenform->formspec = formspec;
	screenform->displaylevel = CF_DISPLAYLEVEL_GENERAL;

	return screenform;
}
